Excellent — below is a **precise, step-by-step checklist** that Antigravity agents should follow to build *Everything Market* from scratch. Each item specifies **who** (Agent or Human) performs it, the exact **artifact** to produce (file paths, env names, SQL), the **gates** (tests / human approvals) required, and the **post-condition** that proves the step is done. Agents may *propose and create* these artifacts but **must not** merge or run production-affecting commands — every merge/run must be human-approved per Antigravity rules.

Use this as `docs/antigravity-checklist.md` and enforce via CI and `agent-policy-check`.

---

# Phase 0 — Onboarding & repo bootstrapping (Agent can create; Human must approve merge)

1. Create repository skeleton (Agent creates PR labeled `agent-proposal`):

   * Files/folders:

     ```
     /docs/
     /docs/specs/
     /docs/runbooks/
     /src/backend/
     /src/frontend/
     /src/orderbook/
     /src/infra/
     /src/playwright-runner/
     /src/infra/idempotency/migrations/
     /.github/workflows/
     /ops/
     ```
   * CI placeholder: `.github/workflows/ci.yml` (basic CI to run lint/tests in sandbox).
   * Gate: Human review + merge.
   * Post-condition: repo created, CI runs on PR with sandbox DB only.

2. Add `docs/antigravity-rules.md` (Agent drafts).

   * Gate: Human approves and merges.
   * Post-condition: CI enforces the rules on PRs.

3. Add `docs/decisions.md` (Agent creates empty template).

   * Gate: Human to fill initial decisions after infra choices.
   * Post-condition: decisions file exists.

---

# Phase 1 — Core infra & config (Agent sets up drafts; Humans provision)

4. Create `jobs` table migration SQL (Agent produces):

   * Path: `src/infra/idempotency/migrations/001_create_jobs.sql` (SQL from masterplan).
   * Gate: run migration in staging by Human.
   * Post-condition: `jobs` table is present in staging DB.

5. Create DB schema & migrations scaffold (Agent):

   * Path: `src/infra/migrations/` with baseline `users`, `markets`, `events`, `audit_event`, `snapshots`, `channel_counters`.
   * Gate: Human to review + deploy to staging Neon.
   * Post-condition: migration applied in staging.

6. Provision managed services (Human):

   * Neon DB, Upstash, Vector DB (Pinecone/Supabase), Object store (S3), Realtime (Ably/Pusher), Vercel project.
   * Create initial env variables in Vercel preview/staging only (no prod secrets). Use `SANDBOX` config for agent previews.
   * Required env names: `NEON_DATABASE_URL`, `UPSTASH_REST_URL`, `VECTOR_DB_URL`, `OBJECT_STORE_URL`, `REALTIME_PROVIDER_KEY`, `HUGGINGFACE_API_KEY`.
   * Post-condition: staging resources available and credentials stored in Vault/Vercel.

7. Add connection pooling doc and configuration (Agent drafts):

   * Path: `docs/specs/db_pooling.md` with recommended `DB_POOL_SIZE` and PgBouncer config.
   * Gate: Infra human approves & sets in Vercel.

---

# Phase 2 — Security primitives & request signing (Agent implements; Human approves)

8. Implement HMAC utility library (Agent writes code + tests).

   * Path: `src/infra/hmac/` (Node/TS util). Include sample header format and verification code.
   * Unit tests: verify signature and replay protection (nonce cache simulated).
   * Gate: Human review + merge.

9. Add middleware guard `guard-admin-decision` (Agent draft) to backend.

   * Path: `src/backend/middleware/guardAdminDecision.ts` (verifies admin_decision before writes).
   * Gate: Human must manually enable in production.
   * Post-condition: middleware exists and is covered by tests.

10. Add key rotation & Vault doc (Agent).

    * Path: `docs/runbooks/key_rotation.md` with `key-id` procedures and emergency revoke steps.
    * Gate: Security human signs off.

---

# Phase 3 — Idempotency & job system (Agent builds; Human runs staging)

11. Implement Jobs API (Agent code + tests):

    * Endpoint: `POST /api/v1/jobs` creates job record with `idempotency_key`.
    * Path: `src/backend/api/jobs.ts`.
    * Tests: idempotency uniqueness, DLQ behavior.
    * Gate: Human runs migrations and executes CI tests against staging DB.

12. Implement DLQ and retry worker (Agent):

    * Path: `src/infra/jobs/worker.ts`. Backoff policy, max attempts config.
    * Gate: Human approves worker to run in sandbox.

---

# Phase 4 — Snapshot & Playwright runner (Agent builds; Human deploys)

13. Implement snapshot contract & tool (Agent):

    * `snapshot_id = sha256(url + "|" + fetched_iso_ts)`; store raw HTML to `snapshots/{snapshot_id}.html`.
    * Path: `src/infra/snapshot.ts` and tests verifying deterministic IDs.
    * Gate: Human review.

14. Build Playwright runner service (Agent produces code + Dockerfile):

    * Path: `src/playwright-runner/` with API `/fetch` accepting `idempotency_key`.
    * Concurrency config: env `PLAYWRIGHT_CONCURRENCY=4`.
    * Throttle: per-domain rate limit default 1/sec.
    * Gate: Human deploys container (Render/Fly).

15. Integrate runner with `reality-worker` (Agent):

    * `reality-worker` posts fetch jobs to runner, runner returns `snapshot_id` and parsed metadata via `POST /api/v1/reality/ingest_callback`.
    * Gate: Human-run test in staging to validate snapshots written to object store.

---

# Phase 5 — Vectorization & LLM (Hugging Face) (Agent integrates; Human approves model)

16. Add embedding batching pipeline (Agent):

    * Path: `src/reality/embeddings/batcher.ts` (batch size env `EMBED_BATCH_SIZE`).
    * Store embeddings to Vector DB with metadata `ingest_id`, `snapshot_id`.
    * Tests: batching/resilience under rate limit simulation.

17. Configure Hugging Face integration (Agent draft):

    * Path: `src/infra/llm/hf_client.ts`. Uses `HUGGINGFACE_API_URL` and `HUGGINGFACE_API_KEY`.
    * Implement JSON Schema validator for LLM outputs (path: `docs/specs/llm_schemas.md`).
    * Gate: Human selects model(s) and updates `docs/decisions.md`.

18. LLM provenance enforcement (Agent code + tests):

    * Reject LLM responses without `snapshot_ids` matching stored snapshots. Log raw output to `llm_raw/{call_id}.json`.
    * Gate: Human tests on staging; model chosen and acceptance criteria documented.

---

# Phase 6 — Reality pipeline & blending (Agent builds; Human gates)

19. Implement `reality-worker` orchestration (Agent):

    * Steps: fetch → snapshot → parse → dedupe → enqueue embeddings → run blender (scoring).
    * Path: `src/reality/worker.ts`. Include deterministic scoring rules per `docs/specs/`.
    * Gate: Human review and run in sandbox.

20. Candidate → final event flow with human-in-loop (Agent + Human):

    * Candidate events created in `candidate_events` table. For `political` or `economic` types, create human-review task.
    * Admin reviews via Admin Console (below) and calls `POST /api/v1/admin/action` to create `admin_decision`.
    * Finalizer service picks approved `candidate_event` and writes `final_event` with `audit_event`.
    * Gate: Human approval required.

---

# Phase 7 — Orderbook & matching engine (Human deploys; Agent tests)

21. Create orderbook service skeleton (Agent):

    * Path: `src/orderbook/` containing in-memory matching logic + WAL writer (`orderbook/wal.js`).
    * WAL format documented and tests that replay WAL produce same state.

22. Human deploys orderbook container (owner: Trading lead):

    * Config: `fsync_every_n=1` for production; snapshot every 10s to `ORDERBOOK_WAL_S3_BUCKET`.
    * Endpoint: `POST /order` forwards accepted orders and emits realtime messages with `sequence_number`.
    * Post-condition: orderbook service running in staging; integration test calls create orders and verifies trade records persisted in Postgres and realtime sequence.

23. CI integration test: warm restart (Agent writes test):

    * Kill orderbook after N orders, restart, replay WAL, assert same book state & trades.
    * Gate: Human reviews test results.

---

# Phase 8 — Realtime & client reconciliation (Agent implements; Human tests)

24. Implement server-side `channel_counters` (Agent):

    * Postgres table to store `channel` → `last_sequence_number`. Expose API to increment atomically.
    * Path: migration and helper lib.

25. Realtime publish flow (Agent):

    * Orderbook and backend publish messages to Realtime provider including `sequence_number`.
    * Path: `src/backend/realtime/publish.ts`.

26. Client reconciling pseudocode & SDK (Agent):

    * Provide client SDK `src/frontend/lib/realtime.ts` with reconciling algorithm (gap detection → fetch snapshot).
    * Gate: Human-run e2e tests in staging.

---

# Phase 9 — Frontend & UX (Agent scaffolds; Human finalizes copy/design)

27. Create Next.js app skeleton separated by `type` sections (Agent):

    * Path: `src/frontend/` with pages: `/discover`, `/market/[symbol]`, `/admin`.
    * UI: type badges: `political`, `economic`, `social`, etc.
    * Implement optimistic UI for orders with `client_order_id`.
    * Gate: Design & Product human approves interactions and copy.

28. Admin console (Agent scaffolds; Human drives):

    * Path: `src/frontend/admin/` with review queue for `candidate_events` and `market_creation_requests`.
    * Admin action triggers `POST /api/v1/admin/action` that creates `admin_decision` (signed by human).
    * Gate: Human auth + audit_event must be created for any publish.

---

# Phase 10 — CI, tests, and PR rules (Agent creates; Human enforces)

29. Add GitHub Action `agent-policy-check` (Agent builds):

    * Validate PR labels, presence of `safety_assertions`, ensure no secrets, ensure tests included for idempotency/HMAC when applicable.
    * Gate: Human to enable action on repo.

30. Add CI concurrency & DB pooling tests (Agent):

    * GitHub Action to run simulated concurrent function calls to ensure DB connections remain below pool size.
    * Gate: Human reviews results.

31. Add e2e chaos tests (Agent writes):

    * Tests to simulate Realtime outage, vector DB failure, LLM failures and verify graceful degradation.
    * Gate: Human approves test results before production.

---

# Phase 11 — Observability, backups & runbooks (Agent drafts; Human verifies)

32. Create SLO & alert docs (Agent):

    * Path: `docs/specs/slos.md` with metrics and alert thresholds (ingest freshness, orderbook latency, embedding queue length).
    * Gate: Ops human must map metrics to monitoring (Datadog/Grafana).

33. Backup & restore runbook (Agent drafts) (critical):

    * Path: `docs/runbooks/backup_restore.md` with step-by-step restore commands for Postgres and orderbook snapshot+WAL replay.
    * Gate: Human performs first manual restore to confirm.

34. Add observability instrumentation (Agent):

    * Emit metrics: `ingest_latency`, `embedding_queue_len`, `orderbook_latency`, `llm_schema_fail_rate`.
    * Gate: Ops human maps to dashboards & alerting.

---

# Phase 12 — Security hardening & audits (Human + Agent)

35. Rotate keys & enable monitoring (Human):

    * Rotate all initial keys, configure Vault, ensure access logs enabled.
    * Post-condition: old keys revoked; audit shows rotation.

36. Pen-test and privacy review (Human):

    * Conduct security review and privacy/GDPR legal checks for snapshot retention and deletion policy.
    * Post-condition: compliance docs updated in `docs/legal.md`.

---

# Phase 13 — Pre-production checklist (Human)

37. Run all integration & chaos tests in staging; fix any failures.
38. Perform orderbook warm-restart test and backup restore test (must pass).
39. Validate human-in-loop flows end-to-end: create candidate_event → admin approval → final_event published with audit_event.
40. Verify no production secrets in preview envs and PRs.
41. Confirm monitoring & alerts are live and on-call assigned.

---

# Phase 14 — Beta release (Human-controlled)

42. Enable production env in Vercel (Human) and deploy frontend & backend.
43. Deploy orderbook with production config (fsync_every_n=1).
44. Start reality ingestion for a limited set of low-risk markets and monitor SLOs closely.
45. Keep `LLM_MODE=degraded` until HF model stability and cost are verified.

---

# Operational governance items (continuous)

* Every agent PR must be labelled `agent-proposal` and require at least one human owner approval before merge.
* Any `admin_decision` action must be recorded in `audit_event` and human-signed.
* Agents must never merge or trigger production runs. They may create PRs and draft artifacts only.
* If DLQ events or safety assertion violations occur, automatically create an incident and set `AGENTS_MODE=paused`.

---

# Quick reference: files & endpoints agents will create

* `src/infra/idempotency/migrations/001_create_jobs.sql`
* `docs/specs/realtime.md`, `docs/specs/ingest_api.md`, `docs/specs/llm_schemas.md`
* `src/infra/hmac/*` (sign/verify utils)
* `src/playwright-runner/` (fetch API + Dockerfile)
* `src/reality/worker.ts`, `src/reality/embeddings/*`, `src/infra/llm/hf_client.ts`
* `src/orderbook/` (wal, snapshot, API)
* `src/frontend/` Next.js skeleton + real-time SDK `src/frontend/lib/realtime.ts`
* `.github/workflows/agent-policy-check.yml` and CI tests

---

# Final enforcement notes (must be automated)

* CI must reject any PR merging attempts that violate `agent-policy-check`.
* Runtime `guard-admin-decision` middleware must reject production writes without human-signed `admin_decision`.
* Incident automation must revoke agent keys automatically when safety assertions are violated.

---

If you want, I’ll now **generate the actual CI Action YAML `agent-policy-check.yml`**, the **pre-commit hook** script, and the **sample `admin_decision` API spec** so Antigravity can immediately propose them in PRs. Which of those three should I produce now?
