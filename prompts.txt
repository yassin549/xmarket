Nice — I converted your master plan into a suite of **professional, copy-pasteable agent prompts** (for human engineers, CI agents, or Antigravity agents). Each prompt is self-contained: role, goal, required inputs, explicit constraints (security, anti-manipulation), expected deliverables, tests/acceptance criteria, and PR checklist. Use these to drive implementation, review, or to feed into an automation pipeline — **but** remember: any automated agent must obey the non-negotiable rule: **do not create or seed any stocks/indexes/assets**.

I grouped prompts by system area (infra, reality-engine, orderbook, backend, frontend, LLM, scrapers, infra/CI/ops, legal & runbooks, and anti-manip). Copy any prompt block directly into an agent or ticket.

# Implementation prompts for Everything Market

---

## 1 — Canonical: High-level engineering / onboarding prompt

```
Role: Senior system architect.
Goal: Create a concise engineering onboarding doc & implementation roadmap derived from the master plan.
Inputs: master-plan.md (the provided Everything Market master plan).
Constraints:
  - All decisions must reference the master plan constants and policies.
  - Explicitly call out the anti-seeding rule for assets.
Deliverables:
  1. single-page engineering onboarding (README_ENGINEERING.md) with architecture diagram, service responsibilities, repo layout, deployment targets (Railway).
  2. Roadmap mapped to the checkpoints (1..7) with owner, effort estimate (T-shirt), and acceptance criteria.
Acceptance criteria:
  - README_ENGINEERING.md created in repo root.
  - Roadmap contains owners and explicit tests for each checkpoint.
PR checklist:
  - Includes unit and integration smoke tests, updated docs/plan.md, no secrets in repo, and link to checklist in Appendix F.
```

---

## 2 — `config/constants.py` prompt

```
Role: Backend Engineer.
Goal: Implement config/constants.py and env loader config/env.py.
Inputs: constants list from master plan.
Constraints:
  - Values must be single source-of-truth and importable by reality-engine, backend, orderbook, frontend server (read-only).
  - No secrets in code — env-only for secrets.
Deliverables:
  - config/constants.py (with comments & types).
  - config/env.py (reads DATABASE_URL, REDIS_URL, REALITY_API_SECRET, ADMIN_API_KEY, POLL_INTERVAL, LLM_MODE, LLM_CALLS_PER_HOUR).
  - Unit tests verifying import and value types.
Acceptance tests:
  - `pytest tests/test_config.py` passes.
  - CI job fails if env variables referenced but missing in test sandbox (allow test to mock envs).
PR checklist:
  - Add docs/plan.md snippet referencing the change.
```

---

## 3 — Postgres schema & Alembic migrations (core tables)

```
Role: DB Engineer.
Goal: Implement Alembic migrations for stocks, scores, events, llm_calls, llm_audit, score_changes, orders, trade_history.
Inputs: Schema definitions in master plan.
Constraints:
  - `events.event_id` UNIQUE; stocks only created via admin endpoints.
  - Use proper indexes and constraints.
Deliverables:
  - alembic revision files in migrations/ for core tables.
  - SQL for indexes + constraints.
  - Smoke script `scripts/db_bootstrap.sh` to apply migrations and create test fixtures.
Acceptance tests:
  - migrations apply clean on a fresh Postgres container.
  - `pytest tests/test_db_schema.py` validates constraints.
PR checklist:
  - include migration names in CHANGELOG.md and docs/plan.md.
```

---

## 4 — Backend skeleton + `/api/v1/reality/ingest`

```
Role: Backend Engineer (FastAPI).
Goal: Implement backend skeleton with POST /api/v1/reality/ingest that verifies HMAC, validates schema, idempotency, and persists events.
Inputs: Appendix A.1 schema, HMAC signing rules (Appendix B), constants/env.
Constraints:
  - Strict signature verification using REALITY_API_SECRET.
  - Validate event_id uniqueness and return 200 for duplicates (idempotency).
  - If abs(impact_points) > SUSPICIOUS_DELTA, write llm_audit (approved=false) and broadcast audit_event with pending_review:true (do not update scores).
Deliverables:
  - FastAPI app with ingest endpoint.
  - Pydantic models for request/response validation.
  - Unit tests for signature verification, idempotency, and suspicious delta flow.
Acceptance tests:
  - Valid signed payload persists event and returns 201.
  - Replayed payload returns 200 without duplication.
  - Suspicious delta path creates llm_audit and does not modify `scores`.
PR checklist:
  - tests, docs update, migration if needed.
```

---

## 5 — Reality-engine poller skeleton (ingest + signer)

```
Role: Reality-engine dev.
Goal: Implement a poller skeleton that reads sources.yaml, fetches feeds, normalizes, and POSTs signed events to backend.
Inputs: sources.yaml (initial sample), constants, signature code snippet.
Constraints:
  - Respect robots.txt and per-domain crawl_delay.
  - Use RSS when available; do not include full raw HTML in DB.
Deliverables:
  - reality-engine skeleton service with:
    - poller scaffold
    - fetch & normalize modules (RSS > newspaper3k > playwright fallback)
    - HMAC signing util and POST client to backend /api/v1/reality/ingest
  - Unit tests and local run script.
Acceptance:
  - Dry-run mode posts canonical signed payloads to a sandbox backend (test server).
PR checklist:
  - Include sample sources.yaml, tests, and note for rate-limiting settings.
```

---

## 6 — Embedding & FAISS indexing module

```
Role: ML/infra engineer.
Goal: Implement deterministic embedding pipeline and FAISS indexing with TTL eviction.
Inputs: embedding model choice (all-MiniLM-L6-v2), VECTOR_WINDOW_SECONDS, SIMILARITY thresholds.
Constraints:
  - Normalize vectors L2, dtype float32.
  - Deterministic pipeline: no randomness in similarity decisions.
Deliverables:
  - embedder module: batch embedding, LRU/Redis cache using embed_cache:<text_hash>.
  - FAISS wrapper with similarity query functions and eviction policy (expire vectors older than VECTOR_WINDOW_SECONDS).
  - Unit tests for dedupe and grouping thresholds (SIMILARITY_DUPLICATE, SIMILARITY_GROUP).
Acceptance:
  - Embedding batch test, dedupe tests pass.
PR checklist:
  - tests + docs update.
```

---

## 7 — Quick scorer (deterministic)

```
Role: NLP engineer.
Goal: Implement quick_score function: 0.4*sentiment + 0.3*keyword_score + 0.3*ner_relevance.
Inputs: spaCy NER, deterministic sentiment module (VADER or deterministic lexicon).
Constraints:
  - Deterministic output for same input.
Deliverables:
  - quick_scorer module and unit tests (varied sample docs).
Acceptance:
  - Given canonical inputs, quick_score is reproducible and within [-1,1].
PR checklist:
  - tests, docs/plan.md update.
```

---

## 8 — LLM runner (tinyLLama) with strict JSON schema

```
Role: LLM infra engineer.
Goal: Implement tinyLLama runner that:
  - accepts grouped docs, quick_score, sources
  - calls LLM with template prompt
  - enforces strict JSON-only output and validates against A.2 schema
Inputs: LLM model config, LLM_QUICK_THRESHOLD, LLM_CALLS_PER_HOUR.
Constraints:
  - Use Redis token-bucket; skip if bucket exhausted (mark llm_mode: "skipped").
  - If LLM output invalid, store parsing error in llm_calls and fall back to deterministic event_points (llm_mode: "failed").
Deliverables:
  - llm_runner module, JSON schema validator, Redis rate-limiter integration.
  - Unit tests for valid, invalid, and skipped flows.
Acceptance:
  - Valid LLM output accepted; invalid stored with error.
PR checklist:
  - tests & docs updated, sample prompt template in docs.
```

---

## 9 — Event weight computation & publish

```
Role: Reality-engine dev.
Goal: Implement `event_weight` and `event_points` computation per spec and sign & publish canonical event.
Inputs: formula from plan (source_trust, num_related_docs, TAU_SECONDS, DELTA_CAP).
Constraints:
  - Round to 2 decimals.
  - Do not exceed DELTA_CAP.
Deliverables:
  - compute_event_points function and unit tests for edge cases (stale events, many docs).
Acceptance:
  - Unit tests cover positive/negative/aging cases.
PR checklist:
  - docs/plan.md updated.
```

---

## 10 — Orderbook core & persistence

```
Role: Orderbook engineer (low-latency matching).
Goal: Implement price-time priority matching engine with persistence in Postgres.
Inputs: orders/trade_history table schema.
Constraints:
  - Price-time priority, partial fills allowed.
  - Orders in-memory for speed, append to Postgres for durability. Rebuild on startup from DB.
Deliverables:
  - In-memory engine, REST API endpoints (POST /orders, POST /cancel, GET /market/{symbol}/snapshot, GET /market/{symbol}/pressure).
  - Startup replay logic.
  - Unit & integration tests simulating matching scenarios (partial fills, cancellations).
Acceptance:
  - Rebuild from DB yields same state; tests for FIFO within price levels pass.
PR checklist:
  - tests, docs, migration scripts if schema changed.
```

---

## 11 — Market pressure / blending API

```
Role: Backend engineer (blender).
Goal: Implement market pressure API used by backend to compute MarketPrice and blending logic for FinalPrice.
Inputs: orderbook endpoints, market_weight/reality_weight fields.
Constraints:
  - Provide buy_volume, sell_volume, net_pressure, normalized market_price (0..100).
Deliverables:
  - /api/v1/market/{symbol}/pressure endpoint with consistent JSON response.
  - Unit tests with synthetic orderbook data to validate normalization logic.
Acceptance:
  - Responses are deterministic and well-documented.
PR checklist:
  - tests, API docs updated.
```

---

## 12 — Backend blender & anti-manipulation enforcement

```
Role: Backend engineer (core).
Goal: Implement blender workflow:
  - validate signature
  - idempotency
  - recompute event_weight defensively
  - anti-manipulation checks (SUSPICIOUS_DELTA)
  - call orderbook/pressure
  - compute FinalPrice and persist `score_changes` atomically
Inputs: constants, events, orderbook API.
Constraints:
  - If |delta| > SUSPICIOUS_DELTA -> create llm_audit (approved=false), broadcast audit_event, DO NOT update scores until approval.
  - Track per-source daily contributions and cap.
Deliverables:
  - backend apply_event flow, anti-manip modules.
  - Unit tests for suspicious delta flows and atomicity.
Acceptance:
  - attempted application of suspicious event leaves scores unchanged and creates audit row.
PR checklist:
  - tests + docs update.
```

---

## 13 — Admin UI & APIs (create stocks, approve audits)

```
Role: Fullstack engineer (admin).
Goal: Implement admin REST endpoints + admin React UI:
  - create stock (ADMIN API only)
  - list & approve/reject llm_audit items
  - view llm_calls and event provenance
Inputs: ADMIN_API_KEY, frontend auth guard stub.
Constraints:
  - Stocks must be created only via admin UI/API and require ADMIN_API_KEY.
  - Audit actions logged with approved_by and timestamps.
Deliverables:
  - Admin endpoints and a protected admin React app with the required views.
Acceptance:
  - Manual test: create stock, trigger suspicious event, approve it, scores update after approval.
PR checklist:
  - Tests for API auth, docs updated with admin usage and audit trail.
```

---

## 14 — Frontend MVP: dashboard, StockCard, Chart, EventsPanel

```
Role: Frontend dev (Vite + React).
Goal: Implement the user dashboard with:
  - StockCard showing FinalPrice/RealityScore/MarketPrice + confidence.
  - Chart with overlay lines and event markers (Chart.js).
  - EventsPanel showing LLM summary, sources, and action buttons for admins (if auth).
Inputs: WS feed schemas (reality_update, market_update, final_update, audit_event).
Constraints:
  - Minimal bundle; lazy-load heavy components (charts, admin).
  - Accessibility contrast & color semantics.
Deliverables:
  - React app with routes: /, /stock/:symbol, /admin (lazy).
  - WS client that subscribes and updates UI.
Acceptance:
  - UI shows real-time data via simulated WS; numeric transitions animate gently.
PR checklist:
  - UI tests, accessibility check, docs/plan.md updated.
```

---

## 15 — Redis roles: rate limiter, embed cache, locks

```
Role: DevOps / infra.
Goal: Implement Redis patterns:
  - Token-bucket for LLM calls
  - embed_cache:<hash> TTL
  - lock:apply_event:<symbol> TTL
Inputs: Redis URL, constants
Constraints:
  - If Redis unavailable: fallback to local best-effort limiter but log & alert; do not allow uncontrolled LLM calls.
Deliverables:
  - Redis helper module with documented methods and unit tests.
Acceptance:
  - Simulated tests for token-bucket behavior and lock race conditions.
PR checklist:
  - docs update and runbook for Redis downtime.
```

---

## 16 — Scraper rules & polite crawling implementation

```
Role: Scraping engineer.
Goal: Implement scrapers respecting robots.txt, RSS-first strategy, crawl delays, caching with ETag/If-Modified-Since.
Inputs: sources.yaml (with trust and crawl_delay).
Constraints:
  - Default per-domain throttle: 1 request / 30s unless overridden in sources.yaml.
  - Playwright fallback only when necessary.
  - No persistent storage of raw HTML without legal approval.
Deliverables:
  - Scraper library with robots parser, RSS fetcher, newspaper3k extractor fallback to playwright.
  - tests that simulate robots disallow and rate-limit behavior.
Acceptance:
  - scrapers honor robots.txt and respond correctly to disallow rules and crawl-delay.
PR checklist:
  - include sample sources.yaml entries and legal flags.
```

---

## 17 — CI, tests & docker-compose integration

```
Role: DevOps / QA engineer.
Goal: Create CI pipeline and docker-compose integration test environment that simulates the whole pipeline (mock external sources).
Inputs: repo, dockerfiles for each service.
Constraints:
  - No auto-deploy on main; tests run on PRs.
  - Include test:full job for heavy integration checks.
Deliverables:
  - .github/workflows/test.yml with unit and integration jobs.
  - docker-compose.test.yml for local full-stack integration with mock services.
Acceptance:
  - PR triggers CI, unit tests pass, and integration smoke tests run successfully.
PR checklist:
  - tests, CHANGELOG entry for CI changes.
```

---

## 18 — Monitoring, logging & alerting

```
Role: SRE.
Goal: Implement logging format, metrics, and basic Grafana dashboard.
Inputs: metrics list (LLM calls/hr, events/hr, ingestion errors, FAISS mem usage, orderbook latency).
Constraints:
  - Structured JSON logs, no secrets.
Deliverables:
  - Logging middleware with correlation_id, a Prometheus metrics exporter or Railway metrics integration, Grafana dashboard sample.
  - Alert rules for LLM overuse and suspicious delta flood.
Acceptance:
  - Demo dashboard and test alert rule triggers.
PR checklist:
  - runbook update.
```

---

## 19 — Backups, deploy & Railway runbook

```
Role: DevOps.
Goal: Implement deployment/runbook using Railway:
  - create services reality-engine, orderbook, backend, frontend
  - set env vars and secrets
  - daily DB backups and restore testing quarterly
Inputs: Railway account->project.
Constraints:
  - Do not auto-deploy main; manual promotion only.
Deliverables:
  - Deployment doc `docs/deploy_railway.md`.
  - scripts for DB backup and restore test.
Acceptance:
  - One-click deploy doc created and tested in staging.
PR checklist:
  - docs and CHANGELOG entry.
```

---

## 20 — Legal & retention implementation

```
Role: Legal + Backend engineer.
Goal: Implement data retention and legal flags for sources.
Inputs: docs/legal.md, sources.yaml flags (paywalled/restricted).
Constraints:
  - Default: do not persist raw scraped text. llm_calls and events retention policy configurable (1 year).
Deliverables:
  - retention worker that purges llm_calls/events older than configured retention.
  - sources.yaml legal flags and validation script.
Acceptance:
  - Retention job runs in dry-run then actual mode; legal flags validated on startup.
PR checklist:
  - docs/legal.md updated and acceptance tests for purge.
```

---

## 21 — Anti-manipulation rules & admin workflow automation

```
Role: Security engineer.
Goal: Implement anti-manip system:
  - cap single-source daily influence
  - z-score spike detector (z>5) to flag
  - audit queue + admin notifications
Inputs: SUSPICIOUS_DELTA, DELTA_CAP.
Constraints:
  - No automatic override of admin decisions. Admin must approve llm_audit before final apply.
Deliverables:
  - anti_manip module, background job to compute per-source rolling counters, detector tests, admin notification integration.
Acceptance:
  - Simulated manipulative events produce audit rows and frontend notifications.
PR checklist:
  - tests & docs.
```

---

## 22 — Runbooks: LLM overuse / suspicious delta flood / orderbook failure

```
Role: Ops lead.
Goal: Write explicit runbooks (playbooks) for the three scenarios in master plan.
Inputs: master plan Section 18.
Constraints:
  - Clear steps, contact list, and rollback/mitigation commands.
Deliverables:
  - three runbook files in docs/runbooks/.
Acceptance:
  - Each runbook tested via tabletop exercise (documented).
PR checklist:
  - link to monitoring alerts and escalation policy.
```

---

## 23 — Deliverable checkpoints -> PR prompts

```
Role: Release manager.
Goal: For each checkpoint (1..7) produce a templated PR prompt that enforces:
  - Single feature/bug per PR, tests included, docs/plan.md updated, no secrets, and anti-seed guard applied.
Inputs: checkpoint list.
Constraints:
  - Agents must create one change per PR.
Deliverables:
  - PR templates for checkpoints, CI checks to enforce tests and docs changes.
Acceptance:
  - PR template used and CI gates enforce tests.
PR checklist:
  - PR body auto-checker verifies inclusion of unit/integration tests and docs update.
```

---

## 24 — Developer & agent rules for Antigravity (policy enforcement)

```
Role: Governance/Policy agent.
Goal: Implement a policy enforcement check that:
  - rejects any PR or automation that adds a seed assets file or creates stocks/indexes programmatically.
Inputs: repository hooks, PR scanner.
Constraints:
  - Must block merges and alert owners on violation.
Deliverables:
  - git pre-receive hook / CI lint step that scans diffs for `stocks` creation scripts or seeded CSVs and fails build with message referencing master plan rule.
Acceptance:
  - Attempt to add seeded assets triggers CI fail with human-readable error and required manual remediation steps.
PR checklist:
  - tests simulating seeded asset addition.
```

---

## 25 — Integration tests & demo script

```
Role: QA engineer.
Goal: Create an end-to-end demo script & integration tests that simulate:
  - reality-engine fetch -> publish -> backend apply_event -> orderbook queries -> frontend WS updates.
Inputs: docker-compose.test.yml, mock sources.
Constraints:
  - deterministic seeds for all tests; no randomness in scoring.
Deliverables:
  - integration tests and demo script that can be run locally to validate end-to-end flow.
Acceptance:
  - `./scripts/run_demo.sh` spins up stack and demonstrates a complete event lifecycle.
PR checklist:
  - test artifacts included and demo documented.
```

---

## 26 — Docs & changelog generator

```
Role: Docs engineer.
Goal: Implement CHANGELOG.md and docs/plan.md generator that pulls from PR metadata and requires threshold/prompt changes to update plan.
Inputs: PR templates, commit messages.
Constraints:
  - Every change to thresholds/prompts must include a CHANGELOG entry with rationale.
Deliverables:
  - changelog tooling and documentation guidelines in docs/.
Acceptance:
  - PR that touches scoring must fail CI unless CHANGELOG updated.
PR checklist:
  - docs + changelog entry present.
```

---

## 27 — Security review & threat model

```
Role: Security architect.
Goal: Produce a short threat model and security checklist for services, focusing on:
  - signature misuse, replay attacks, admin key theft, LLM prompt injection, scraper abuse.
Inputs: master plan, env variables.
Constraints:
  - Provide mitigations and required tests.
Deliverables:
  - threat-model.md and a security checklist (hardening actions).
Acceptance:
  - Threat model reviewed by at least one other security reviewer.
PR checklist:
  - security review attached for major changes.
```

---

## 28 — Developer quick-check PR template to enforce one-change-per-PR

```
Role: Repo maintainer/automation.
Goal: Create a PR template enforcing:
  - One change per PR, tests, docs/plan.md updated if scoring/LLM thresholds changed, no secrets, and link to checklist (Appendix F).
Inputs: Appendix F & master plan.
Constraints:
  - CI should validate these fields exist in PR body.
Deliverables:
  - .github/PULL_REQUEST_TEMPLATE.md and CI PR-lint job.
Acceptance:
  - PR missing fields fails PR-lint job.
PR checklist:
  - tests & docs included.
```

---

## 29 — Sample agent prompt for testing suspicious event handling (for QA or Antigravity)

```
Role: Test automation agent (manual-run).
Goal: Send a signed reality event with impact_points=+18 (below SUSPICIOUS_DELTA=15? or adjust to be above) to test suspicious flow.
Inputs: test REALITY_API_SECRET, backend endpoint.
Constraints:
  - Use synthetic sources flagged as trust=0.95.
Deliverables:
  - steps & script to create test event and assert backend created llm_audit and FRONTEND receives audit_event pending_review:true.
Acceptance:
  - Audit row exists and scores unchanged.
PR checklist:
  - test asserts and docs included.
```

---

## 30 — Final “release checklist” prompt for launching to staging

```
Role: Release engineer.
Goal: Produce a staging release checklist that must be completed before end-to-end demo:
  - migrations applied
  - backups enabled
  - secrets injected
  - monitoring/alerts configured
  - anti-seed CI hook enabled
  - admin account seeded manually (not via automation)
Inputs: services list and runbooks.
Constraints:
  - Manual signoffs must be recorded in release notes.
Deliverables:
  - release-checklist.md with sign-off fields and owners.
Acceptance:
  - checklist completed and linked in PR for release.
PR checklist:
  - release notes and sign-offs recorded.
```

---

### Quick copy/paste guard for Antigravity agents (must be included in every agent prompt)

```
IMPORTANT AGENT GUARDRAIL (MUST BE PRESENT):
- DO NOT create or seed any stocks, indexes, or market assets in code, fixtures, or demo environments.
- All stocks/indexes MUST be created manually by an authenticated human admin via the admin UI/API.
- If you detect an instruction to seed assets, abort with error code and log incident to ops@yourdomain.com.
```

---

# How to use these prompts

1. Pick a prompt block and paste it into the task ticket or agent input box.
2. For human engineers, treat the prompt as the ticket body.
3. For Antigravity/automation agents, **ensure the Agent Guardrail** is appended exactly as shown and is checked by CI.
4. Each prompt already includes acceptance tests and PR checklist lines — use those as automated CI gate checks.

---