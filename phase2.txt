# Xmarket — Phase 2

**Platform Name**: Xmarket  
**Slogan**: "Trade Everything"

**Goal:** Provide 10 production-ready Cursor prompts that take Phase 1 to production-grade. Extra emphasis on **design polish, frontend UI/UX, performance, and robust logic**. Each prompt follows a strict structure: *Purpose, Context/Stack, Deliverables, Files to produce, Acceptance Criteria, Tests & commands, Implementation notes & constraints.*

---

## Prompt 1 — High-performance Matching Engine (Rust or Go)

**Purpose**
Implement a low-latency, horizontally scalable orderbook matching engine capable of handling 10k+ orders/sec for top markets, with a deterministic reconciliation log for auditing and replay.

**Context / Stack**
Rust (recommended) or Go implementation; gRPC + Protobuf API for order intake from the Node gateway; write-ahead log (WAL) persisted to disk; snapshots to S3-compatible storage; in-memory orderbook with lock-free data structures where appropriate.

**Deliverables**

* Matching engine service implementing limit, market, IOC, and cancel orders, order lifecycle events, trade execution, and fee accounting.
* gRPC API definition (protobuf) for `PlaceOrder`, `CancelOrder`, `OrderStatus`, and `Snapshot` RPCs.
* WAL + snapshot mechanism and a CLI tool to replay WALs for reconstruction and auditing.
* Dockerfile, Kubernetes manifests (Helm chart), and CI tests.

**Files to produce**

* `matching-engine/proto/orders.proto`
* `matching-engine/src/main.rs` (or `cmd/main.go`)
* `matching-engine/src/wal.rs` + `replay_tool.rs`
* `matching-engine/helm-chart/*` + Dockerfile

**Acceptance criteria**

* Engine passes synthetic load test at 10k orders/sec for simple limit orders on a single market with median latency < 10ms and p99 < 100ms (on a reasonable beefy instance).
* WAL replay reconstructs orderbook and trade history byte-for-byte.

**Tests & commands**

* `cargo test` or `go test` unit tests for matching logic.
* `./replay_tool --wal ./data/wal.log --snapshot ./snap.bin` reproduces `./snap.bin`.
* Load test script (`tools/loadtest/run.sh`) that verifies throughput.

**Implementation notes & constraints**

* Use atomic primitives; avoid GC pauses in Go by careful memory usage or prefer Rust for predictable latencies.
* Keep deterministic timestamping and sequence numbers for every event.

---

## Prompt 2 — Perpetuals & Funding Rate Engine (Deterministic financial logic)

**Purpose**
Design and implement the perpetual contract mechanics: mark price derivation, funding rate calculation, settlement mechanics, and configurable safety clamps. **Critical for sentiment markets** to prevent one-sided manipulation.

**Context / Stack**
TypeScript microservice or Rust service that computes funding every configurable interval (default 8 hours), persists history, and posts funding events to Redis/Kafka to be consumed by positions & margin services.

**Funding Rate Formula**:
```
OI_long = Total open interest on long positions ($)
OI_short = Total open interest on short positions ($)
OI_total = OI_long + OI_short
imbalance = (OI_long - OI_short) / OI_total
funding_rate = clamp(imbalance * k, -max_rate, +max_rate)

Where:
- k = sensitivity constant (default 0.01)
- max_rate = maximum funding rate per period (default 0.01 = 1% per 8 hours)
```

**Deliverables**

* Funding engine service that calculates funding per-market using the imbalance-based formula above (with optional TWAP anchoring for advanced markets).
* Config UI panel (admin) to adjust `k`, `max_rate`, `interval`, and TWAP window.
* Unit tests with deterministic examples: OI_long=$1.2M, OI_short=$800k → funding_rate=0.2% per 8h (longs pay shorts).
* Integration test: Create long/short positions, run funding engine, verify margin adjustments.

**Files to produce**

* `services/funding/src/index.ts` (or Rust)
* `services/funding/config.schema.yaml`
* `apps/web/app/admin/funding/page.tsx` (admin UI)

**Acceptance criteria**

* Funding engine publishes funding events at configured intervals; `funding_rate` values match deterministic test cases.
* Funding events cause PnL transfers between longs and shorts in a test harness.

**Tests & commands**

* Unit tests asserting funding math on sample OI numbers.
* Integration test: run funding engine + positions service, create long/short positions, verify funding debits/credits.

**Implementation notes & constraints**

* **For sentiment markets (MVP)**: Use simple imbalance-based funding (no TWAP needed).
* **For index markets (future)**: Use TWAP from recent price ticks to anchor funding and avoid oracle flash attacks.
* Funding applies to all open positions every 8 hours (configurable). Longs pay shorts if rate > 0, shorts pay longs if rate < 0.
* Clamp rates to prevent runaway: `max(min(funding_rate, +0.01), -0.01)`.

---

## Prompt 3 — Robust Liquidation Engine, Insurance Fund & ADL

**Purpose**
Implement deterministic liquidation logic, an insurance fund accounting system, and Auto-Deleveraging (ADL) fallback for insolvency scenarios.

**Context / Stack**
High-performance background worker (Rust/Go/TS) able to process position state changes fast. Insurance ledger in Postgres with auditable entries. ADL algorithm to allocate risk to opposing positions when insurance fund is insufficient.

**Deliverables**

* Liquidation worker that monitors positions and performs market close, with partial-close option and optimistic off-chain auction flow stub.
* Insurance fund accounting endpoints and admin UI.
* ADL implementation with deterministic selection and prioritization rules.

**Files to produce**

* `services/liquidator/src/*`
* `services/liquidator/algorithms/adl.rs` or `.go`
* `apps/web/app/admin/liquidations/page.tsx`

**Acceptance criteria**

* Under test scenarios where positions become insolvent, liquidator closes positions and insurance fund updates correctly. ADL triggers in tests when insurance < shortfall and logs are auditable.

**Tests & commands**

* Integration tests simulating a crash scenario with multiple liquidations and verifying final balances.

**Implementation notes & constraints**

* Keep liquidation logic idempotent and resumable. All state transitions must be transactional.

---

## Prompt 4 — KYC / AML, Compliance Controls & Geofencing

**Purpose**
Implement compliant KYC flows for higher-risk users, AML monitoring rules, geofencing, and a legal-safe feature toggle system to restrict jurisdictions or features.

**Context / Stack**
Integrate with providers (e.g., Persona, Onfido, Sumsub) for KYC; use third-party fiat partners (Stripe/Circle) for fiat; implement AML heuristics and alerting; maintain an admin dashboard for compliance actions.

**Deliverables**

* KYC webhook handlers & onboarding flows (`/api/kyc/*`).
* AML rules engine with configurable rules (velocity, structuring, anomalous PnL).
* Geofencing middleware to block requests and features by IP + declared residency.
* Compliance admin UI with case management.

**Files to produce**

* `services/kyc/*` integration code
* `apps/web/app/onboarding/kyc/page.tsx`
* `services/compliance/rules.yaml`

**Acceptance criteria**

* KYC provider success/fail flows fully testable via mocks. Geofencing blocks requests from configured countries. Compliance events generate tickets in admin UI.

**Tests & commands**

* Mocked KYC provider tests. AML rule unit tests with example suspicious traces.

**Implementation notes & constraints**

* Legal counsel must review flows; store PII encrypted-at-rest and rotate keys.

---

## Prompt 5 — Enhanced Multi-Stablecoin Support & Advanced Withdrawal Features

**Purpose**
Expand stablecoin support to all major networks and tokens, implement advanced withdrawal features (saved addresses, batch withdrawals), and optimize hot wallet management with predictive replenishment.

**Context / Stack**
Alchemy SDK for all networks, CoinGecko API for expanded token support, advanced hot wallet management, Fastify routes for enhanced withdrawal features.

**Deliverables**

* Expanded stablecoin support:
  - Add Arbitrum, Optimism, Avalanche networks
  - Add PYUSD support
  - Support for additional stablecoins as they emerge
* Advanced withdrawal features:
  - Saved withdrawal addresses (users can save frequently used addresses)
  - Batch withdrawals (process multiple withdrawals in one transaction)
  - Withdrawal scheduling (future-dated withdrawals)
  - Withdrawal templates (pre-configured withdrawal settings)
* Predictive hot wallet management:
  - Analyze withdrawal velocity patterns
  - Predict hot wallet needs
  - Auto-replenish before running low
  - Optimize hot wallet balances based on usage
* Enhanced monitoring:
  - Real-time hot wallet balance dashboard
  - Withdrawal velocity metrics
  - Network fee optimization
  - Multi-network transaction monitoring

**Files to produce**

* `services/api/src/services/withdrawalService.ts` (enhanced)
* `services/api/src/services/hotWalletService.ts` (enhanced with predictive features)
* `services/api/src/routes/wallet.ts` (saved addresses, batch withdrawals)
* `apps/web/app/dashboard/withdraw/page.tsx` (enhanced UI)
* `apps/web/app/admin/hot-wallets/page.tsx` (admin dashboard)

**Acceptance criteria**

* All major stablecoins supported on all major networks.
* Users can save and reuse withdrawal addresses.
* Hot wallet replenishment happens proactively based on patterns.
* Withdrawal processing time < 30 seconds for 95% of withdrawals.

**Tests & commands**

* Integration tests for all new stablecoin/network combinations.
* Test predictive hot wallet replenishment.
* Load test withdrawal processing.

**Implementation notes & constraints**

* Monitor network fees and optimize transaction timing (e.g., send during low-fee periods).
* Implement circuit breakers for hot wallet replenishment (prevent runaway transfers).
* Document all supported tokens and networks in API docs.

---

## Prompt 6 — Design System, Component Library & Figma Tokens (Polish + Accessibility)

**Purpose**
Create a production-ready design system with reusable components, Figma tokens, motion system, accessibility standards, and high-fidelity UI kit that the devs can implement identically. **Emphasize trustworthy finance aesthetic, mobile-first, and clear risk communication**.

**Context / Stack**
Design in Figma; implement React component library in `apps/web/components` using shadcn/ui primitives, Tailwind tokens, Framer Motion for animations, and Storybook for docs.

**Design Principles**:
- **Trustworthy Finance Aesthetic**: Clean, professional, data-dense but readable
- **Color Palette**: Deep blue/purple (primary), Green (profits/bullish), Red (losses/bearish), Gray scale (backgrounds)
- **Typography**: Bold headings, monospace for numbers/prices, readable sans-serif for body
- **Mobile-First**: One-handed operation, bottom navigation, 44x44px touch targets
- **Risk Communication**: Clear warnings, liquidation price display, funding rate indicators, visual risk levels

**Deliverables**

* Figma file with page templates (Market page, Trade Modal, Create Market, Dashboard, Admin panels) and token export.
* React component library: `Button`, `Modal`, `TradeForm`, `Chart`, `Leaderboard`, `MarketCard`, `ResponsiveGrid`, with accessible patterns and motion tokens.
* Storybook stories and unit tests for components.

**Files to produce**

* `design/EverythingMarket.fig` (Figma export / link placeholder)
* `apps/web/components/*` (component library)
* `apps/web/.storybook/*`

**Acceptance criteria**

* Designers and developers can run Storybook and match Figma pixels within 95% visual parity for key pages. All interactive components meet WCAG AA contrast and keyboard navigation.

**Tests & commands**

* Visual regression tests using Playwright snapshot testing. Accessibility checks in CI using axe.

**Implementation notes & constraints**

* Create motion guidelines (subtle easing, 120–240ms durations) and limit heavy 3D transforms to preserve perf on mobile.

---

## Prompt 7 — Frontend Performance & Advanced UX (Optimizations)

**Purpose**
Optimize frontend for sub-100ms perceived interactions: clever caching strategies, streaming UI, skeleton states, progressive hydration, and off-main-thread heavy work.

**Context / Stack**
Next.js app with React server components, SWR or React Query for caching, Web Workers for heavy charting transforms, and CDN caching strategies.

**Deliverables**

* Implementation plan & code for streaming market page with SSR skeleton, incremental static regeneration for low-change pages, and client-side incremental updates for live data.
* Web Worker module for chart aggregation & downsampling (largest N points) to avoid main-thread jank.
* Lighthouse perf benchmark targets and scripts.

**Files to produce**

* `apps/web/app/markets/[slug]/page.server.tsx` (streaming + SSR)
* `apps/web/public/workers/chartWorker.js`
* `tools/perf/run_lighthouse.sh`

**Acceptance criteria**

* Market page Lighthouse performance score ≥ 90 on desktop and ≥ 75 on mobile (emulated).
* Initial TTFB < 200ms on a cold load from CDN (reasonable infra assumptions).

**Tests & commands**

* `tools/perf/run_lighthouse.sh https://local.test/markets/viral` outputs scores and asserts thresholds.

**Implementation notes & constraints**

* Avoid heavy client bundles; prioritize code-splitting and dynamic imports. Use matrix of device throttles for perf tests.

---

## Prompt 8 — Scalability & Distributed Systems (DB, Replication, CQRS)

**Purpose**
Design and implement a scalable backend architecture fit for growth: read replicas, partitioning/sharding strategies for heavy tables, CQRS/event-sourcing where appropriate, and autoscaling infra.

**Context / Stack**
Postgres primary + read replicas, Kafka for event streaming, materialized views for expensive aggregates, and separated OLTP/OLAP stacks. Provide Kubernetes manifests and Horizontal Pod Autoscaler configs.

**Deliverables**

* Architecture doc and infra manifests for database replication, Kafka topics, consumer groups, and HPA settings.
* Implement CQRS pattern: write model (Postgres) + read model (materialized views + Redis) with sync workers.
* DB migration plan and partitioning example for `trades` and `events` tables.

**Files to produce**

* `infra/arch.md`
* `infra/k8s/*` (HPA, statefulset for Postgres operator example)
* `services/sync/readerUpdater.ts`

**Acceptance criteria**

* Demonstrable load test that scales API pods, read replicas reduce load on primary, and read latency stays < 50ms for hot endpoints.

**Tests & commands**

* `tools/loadtest/run_scale_test.sh` that simulates 1000 concurrent users and scales pods.

**Implementation notes & constraints**

* Use logical partitioning by `market_id` for very high-volume tables; consider time-based partitions for historical data.

---

## Prompt 9 — Security, Audit, & Pen Testing (Production hardening)

**Purpose**
Harden the platform with security best practices, produce an audit plan, and prepare for third-party penetration tests and smart contract audits (if applicable).

**Context / Stack**
OWASP ASVS alignment for web services, CI checks for dependency vulnerabilities, secrets scanning, infra-level hardening, and a vulnerability disclosure program.

**Deliverables**

* Security checklist & remediation tasks.
* CI integration for Snyk/Dependabot, Secret scanning, and static analysis (Rust Clippy for engine).
* Pen-test engagement scope and a prioritized vulnerability fix plan.
* Playbook for incident response and public disclosure.

**Files to produce**

* `security/plan.md`
* `.github/workflows/security.yml` (Snyk/Dependabot exec)
* `ops/runbooks/incident_response.md`

**Acceptance criteria**

* No high severity vulnerabilities in critical dependencies (CI gating). Pre-engagement bug bounty scaffold ready.

**Tests & commands**

* `pnpm -w test` includes `npm audit` and fails on high severity.

**Implementation notes & constraints**

* Rotate keys, enforce least privilege on all cloud roles, and run scheduled audits.

---

## Prompt 10 — Production Launch Plan, SRE, Observability & Legal Checklist

**Purpose**
Create a thorough production launch plan: SRE runbooks, SLA objectives, observability dashboards, incident drills, and a legal checklist (jurisdictions, filings, token/tax considerations).

**Context / Stack**
Prometheus + Grafana, Sentry, Honeycomb (optional), PagerDuty for alerts, and legal counsel for jurisdictional requirements.

**Deliverables**

* Launch checklist with go/no-go criteria across product, infra, legal, and security.
* SRE runbooks for common incidents (matching engine down, WAL corruption, runaway funding events).
* Observability dashboards JSON for Grafana; alert rules for key metrics.
* Legal checklist with recommended counsel actions.

**Files to produce**

* `ops/launch_checklist.md`
* `ops/runbooks/*.md` (matching_engine_restart.md, wallet_reconcile.md, high_funding_rate.md)
* `infra/observability/grafana_dashboard.json`

**Acceptance criteria**

* All go/no-go items green in a dry-run. Alerting tested with simulated incidents; paging works end-to-end.

**Tests & commands**

* `./ops/drills/run_incident_sim.sh` simulates a crash and verifies runbook steps and alerting.

**Implementation notes & constraints**

* Legal checklist must be reviewed and signed off by counsel before real-money operations beyond sandbox.

---

## Additional Phase 2 Considerations

### Event Market Resolution (Oracle Integration)
- **Purpose**: Enable event markets that resolve to YES/NO outcomes
- **Implementation**: Integrate with Chainlink, UMA, or centralized oracle for MVP
- **Flow**: Market creator sets resolution criteria → Oracle resolves at resolution_date → Positions settle at 0.0 or 100.0
- **Note**: This is optional for Phase 2; sentiment markets (perpetual) are the primary focus

### Index Markets (External Data Feeds)
- **Purpose**: Markets tied to external data (e.g., "Bitcoin adoption rate" tracks actual metrics)
- **Implementation**: Oracle feeds update market price, but sentiment can still diverge
- **Use Case**: Bridge between sentiment markets and traditional indices

### Creator Tools & Analytics
- Creator dashboard: Market performance, fees earned, trader analytics
- Promotion tools: Boost markets, sponsor in feeds
- Analytics: Volume trends, price movements, trader demographics

### Social Features
- Comments on markets
- Share to X/Twitter, embed widgets
- Leaderboards (best predictors, top traders)
- Copy-trade: Follow top traders' positions

---

## Additional Phase 2 Considerations

### Enhanced Deposit/Withdrawal Features
- **Deposit Limits**: Configurable limits per user tier (unverified, verified, VIP)
- **Withdrawal Limits**: Dynamic limits based on user activity and risk profile
- **Multi-Signature Withdrawals**: For large withdrawals, require multiple approvals
- **Withdrawal Scheduling**: Users can schedule withdrawals for future dates
- **Deposit Notifications**: Real-time push notifications for deposit confirmations
- **Withdrawal Tracking**: Real-time tracking with blockchain explorer links

### Advanced Hot Wallet Management
- **Multi-Signature Hot Wallets**: Enhanced security for hot wallets
- **Geographic Distribution**: Hot wallets in different regions for redundancy
- **Automated Rebalancing**: Automatically move funds between hot/cold based on patterns
- **Fee Optimization**: Batch withdrawals to reduce network fees
- **Cold Storage Integration**: Seamless integration with cold storage providers

### Compliance & Security Enhancements
- **Enhanced KYC Integration**: Full KYC flows for high-volume users
- **AML Monitoring**: Advanced AML rules and suspicious activity detection
- **Transaction Monitoring**: Real-time monitoring of all deposits/withdrawals
- **Audit Trail**: Complete audit trail for all financial operations
- **Insurance Coverage**: Platform insurance for custodial funds

### API Enhancements
- **Webhook System**: Allow users to set up webhooks for deposit/withdrawal events
- **API Keys**: Allow users to generate API keys for programmatic access
- **Rate Limiting**: Advanced rate limiting per user tier
- **API Documentation**: Comprehensive API docs with examples

---

## Final notes for Cursor usage

* Each prompt must be executed as a separate Cursor job; include unit & integration tests for every deliverable.
* Emphasize deterministic finance logic, immutable logging for auditability, pixel-perfect UI parity with Figma, and performance SLAs for matching and UI responsiveness.
* **Remember**: We're building perpetual sentiment contracts, not traditional stocks or binary prediction markets. Price = collective sentiment index, discovered through trading.
* **Custodial System**: Xmarket uses custodial wallets - users deposit directly to platform addresses, no wallet connection needed. All deposits converted to unified USD balance.
* **Multi-Stablecoin**: Support all major stablecoins (USDC, USDT, DAI, PYUSD) on multiple networks (Ethereum, Polygon, Base, Arbitrum, Optimism, Avalanche).
* **Instant Withdrawals**: Users can withdraw instantly without platform permission - fully automated system with hot wallet management.

---