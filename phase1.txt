# Xmarket — Phase 1 (Solo Builder Edition)

**Platform Name**: Xmarket  
**Slogan**: "Trade Everything"

You are the sole engineer/designer/operator responsible for delivering Phase 1 end-to-end. Each prompt must be runnable sequentially in Cursor and contains: *Purpose, Dependencies, Context/Stack, Deliverables, Files, Acceptance Criteria, Tests & Commands, Implementation Notes.* All UX decisions should lean toward mobile-first, high-trust finance aesthetics, and accessible interactions.

**Global stack constraints**
- Monorepo with `pnpm` workspaces: `apps/web` (Next.js app router + Tailwind + shadcn/ui + Radix), `services/api` (Fastify + TypeScript), shared `packages/types`, `packages/config`.
- Postgres via Prisma, Redis for cache/pub-sub, Jest + Playwright tests, Storybook for components.
- Deployment target: Railway. Env secrets stored in Railway + `.env.example` placeholders. Default ports: web `3000`, API `4000`.
- Code must be production-friendly (typed, linted, formatted) because there is no other team to clean up later.

---

## Prompt 1 — Repo scaffold, Dev UX & CI bootstrap

**Purpose**  
Create a monorepo scaffold with batteries included so every later prompt plugs in cleanly.

**Dependencies**  
None (run first).

**Context / Stack**  
Next.js 14 app dir, Fastify API, shared TypeScript config, Turbo/PNPM scripts, Tailwind, shadcn/ui, ESLint/Prettier, Vitest/Jest, GitHub Actions.

**Deliverables**
- Monorepo structure with workspaces, root scripts (`dev`, `lint`, `test`, `typecheck`, `build`).
- Dockerfiles for web + api, `.env.example`, `README.md` (local + Railway instructions), `.nvmrc`.
- GitHub Actions workflow (`ci.yml`) running lint + tests + typecheck.
- Base Tailwind config with design tokens placeholder (light/dark, spacing scale).

**Files**
- `package.json`, `pnpm-workspace.yaml`, `turbo.json`.
- `/apps/web/*`, `/services/api/*`, `/packages/types/*`.
- `.github/workflows/ci.yml`, `.editorconfig`, `.prettierrc`.

**Acceptance Criteria**
- `pnpm install` works root-wide.
- `pnpm dev` starts both apps via Turbo concurrently.
- `pnpm lint && pnpm test && pnpm typecheck` succeed locally and in CI.
- Docker builds for both apps succeed (`docker build apps/web`, `docker build services/api`).

**Tests & Commands**
- `pnpm lint`, `pnpm typecheck`, `pnpm test`, `pnpm dev`.

**Implementation Notes**
- Include VSCode settings + recommended extensions.
- Document environment variables (JWT secret, DB URLs, Redis) with development defaults.
- Provide `scripts/bootstrap.sh` that seeds local env (install Husky, prepare Prisma, etc.).

---

## Prompt 2 — Iterative database schema & migrations

**Purpose**  
Design a lean but extensible Prisma schema for Phase 1 (users, wallets, AMM markets/trades, audit logs) with deterministic migrations and seeds.

**Dependencies**  
Prompt 1 scaffold.

**Context / Stack**  
Prisma + Postgres 15. Single database with future-proof naming (snake_case). Use UUID PKs, audited timestamps, soft deletes where needed.

**Deliverables**
- Prisma schema containing only MVP tables: `User`, `Wallet`, `WalletLedgerEntry`, `Market`, `MarketLiquidityConfig`, `AMMReserveSnapshot`, `Trade`, `Position`, `CreatorFeeShare`, `EventLog`.
- Market schema must include: `market_type` enum ('event' | 'sentiment' | 'index'), `price_scale` (min/max), `resolution_date` (optional), `resolution_criteria` (optional).
- Seed script creating: admin + sample user, sample sentiment market seeded with $10k USDC / 200 shares (initial price 50.0), example trades.
- Migration README describing ordering strategy + how to add future tables.
- Index recommendations (B-tree on `market_id`, partial indexes for open positions).

**Files**
- `prisma/schema.prisma`, `prisma/migrations/*`, `prisma/seed.ts`.
- `services/api/src/lib/prisma.ts` (singleton client).

**Acceptance Criteria**
- `pnpm prisma:migrate` (script) succeeds from clean DB.
- `pnpm prisma:seed` inserts data; `pnpm ts-node scripts/check-db.ts` verifies sample market/reserve alignment.
- Schema lint (`pnpm prisma format`) clean.

**Tests & Commands**
- `pnpm prisma migrate dev --name init`
- `pnpm ts-node prisma/seed.ts`

**Implementation Notes**
- Keep financial values as `Decimal` (Prisma Decimal, 18 precision). Document rounding strategy.
- Store derived totals (e.g., `Market.current_price`) only if justified; otherwise compute from reserves.
- Outline upgrade path for Phase 2 tables (matching engine orderbook) in migration README without creating them yet.

---

## Prompt 3 — Auth, security posture & custodial wallet ledger

**Purpose**  
Ship secure auth endpoints, password policies, JWT lifecycle, and custodial wallet ledger (mock USDC) with faucet + withdrawal stubs.

**Dependencies**  
Prompts 1-2 (schema + env).

**Context / Stack**  
Fastify routes, Zod validation, bcrypt password hashing, JWT (HS256) short-lived access token + refresh token cookie, Redis for session revocation. Wallet ledger uses double-entry representation (credit/debit entries).

**Deliverables**
- Endpoints: `POST /auth/register`, `POST /auth/login`, `POST /auth/refresh`, `POST /auth/logout`, `GET /auth/me`.
- Wallet endpoints: `GET /wallet/balance`, `POST /wallet/faucet` (restricted via admin API key env), `POST /wallet/withdraw` (mock), `GET /wallet/ledger`.
- Middleware: rate limiter (per IP + per user), auth guard, admin-only guard, geo-safe IP logging placeholder.
- Security utilities: password strength validator, refresh token rotation, account lock after configurable failed attempts.

**Files**
- `services/api/src/routes/auth.ts`, `wallet.ts`.
- `services/api/src/middleware/authGuard.ts`, `rateLimit.ts`.
- `services/api/src/services/walletService.ts`, `authService.ts`.
- Tests under `services/api/tests/auth.spec.ts`, `wallet.spec.ts`.

**Acceptance Criteria**
- Register/login returns tokens, `GET /auth/me` returns profile.
- Faucet requires `X-Admin-Key` header, credits ledger (two entries) and updates wallet balance atomically.
- Withdraw stub deducts funds, enqueues event log entry for later fiat/off-chain integration.
- Rate limits enforced (configurable). Password policy documented in README.

**Tests & Commands**
- `pnpm test auth`
- Integration test hitting register/login/faucet/balance flows.

**Implementation Notes**
- Store `kyc_status` enum though flows disabled. Document next steps.
- Use `argon2id` if libs available; else bcrypt with cost 12+.
- Emit structured logs for every auth/wallet action (JSON).

---

## Prompt 4 — Deterministic AMM service & liquidity lifecycle

**Purpose**  
Implement CPMM engine with full lifecycle (quote, swap, add/remove liquidity) using fixed-point math and fee routing.

**Dependencies**  
Prompts 1-3 (schema + wallet).

**Context / Stack**  
TypeScript AMM module (pure functions) + Fastify routes. **Use Decimal.js for precise decimal math** (18 precision). Fee policy: 0.25% swap fee (80% LPs, 20% protocol). Liquidity seeded via market creation.

**Key AMM Formula**: 
- Price = `R_quote / R_base` (USDC per share)
- Constant product: `k = R_quote * R_base` (must remain constant)
- When buying shares: solve for `R_quote_new` given target `R_base_new`, then `ΔQ = R_quote_new - R_quote`
- Apply fee after calculating swap amount

**Deliverables**
- Routes: `POST /amm/quote`, `POST /amm/swap`, `POST /amm/add-liquidity`, `POST /amm/remove-liquidity`, `GET /amm/:market/reserves`.
- Service functions: `getSpotPrice`, `simulateSwap`, `executeSwap`, `rebalanceReserves`, `recordFee`.
- Transactional consistency: swap + ledger updates + reserve snapshots happen in single DB transaction with retry on serialization failure.
- Deterministic test replicating: Start with R_quote=10,000, R_base=200 (price=50.0), buy 10 shares → verify price moves to ~55.40, user pays ~527.64 USDC (including 0.25% fee).

**Files**
- `services/api/src/services/ammService.ts`, `ammMath.ts`.
- `services/api/src/routes/amm.ts`.
- `services/api/tests/amm.math.spec.ts`, `amm.routes.spec.ts`.

**Acceptance Criteria**
- Quote endpoint returns exact output, slippage, post-trade price, fees.
- Swaps emit Redis event `market.{id}.trade` with schema `{version, eventType, marketId, price, size, side, ts}`.
- Liquidity operations respect min share thresholds and pro-rata share accounting.

**Tests & Commands**
- `pnpm test amm`
- Snapshot tests verifying fee splits + ledger entries.

**Implementation Notes**
- Enforce 18-decimal scaling constant.
- Document error codes (e.g., `AMM_INSUFFICIENT_LIQUIDITY`).
- Provide metrics instrumentation (histogram for swap latency, counter for fees).

---

## Prompt 5 — Market creation, validation & preview API

**Purpose**  
Allow creators to spin up markets with guardrails, automatically seed AMM reserves, and preview slippage scenarios.

**Dependencies**  
Prompts 1-4.

**Context / Stack**  
Authenticated creators (role flag). Slug generation, duplicate prevention, optional private markets. Business rules baked into config file.

**Deliverables**
- `POST /markets` (title, description, tags, **market_type** ('event' | 'sentiment' | 'index'), initial_price, **price_scale** {min, max}, resolution_date (optional), resolution_criteria (optional), liquidity_model, creator_fee_pct, seed_amount_usdc, visibility).
- `GET /markets/:id`, `GET /markets/:id/preview` (return simulated slippage for trade sizes $100, $1k, $10k).
- `GET /markets` list with filters (status, creator, market_type, liquidity model).
- Server emits `market.created` event with marketing metadata for later notifications.
- Market initialization: Calculate `R_base = seed_amount / initial_price`, set `R_quote = seed_amount`, `k = R_quote * R_base`.
- Deducts seed amount from creator wallet and mints LP shares (protocol share if platform seeding).

**Files**
- `services/api/src/routes/markets.ts`.
- `services/api/src/services/marketService.ts`.
- Validation schema in `services/api/src/schemas/market.ts`.
- Tests `markets.spec.ts`.

**Acceptance Criteria**
- Slug uniqueness enforced; duplicate creation returns 409.
- Seed must be ≥ $1,000 and ≤ user wallet balance. Creator fee default 20%, max 50%; config file documents reasoning.
- Preview endpoint uses AMM math (no DB writes) and returns slippage table + warnings (e.g., “>5% impact”).

**Tests & Commands**
- Unit tests for positive and negative flows.
- Contract test verifying event payload.

**Implementation Notes**
- Include `market_risks` field for future disclaimers.
- Provide admin override to pause markets.

---

## Prompt 6 — Frontend core flows & design language setup

**Purpose**  
Deliver user-facing surfaces (Landing, Market page, Create Market wizard, Dashboard) with cohesive design system tokens and responsive behavior.

**Dependencies**  
Prompts 1-5 (APIs ready).

**Context / Stack**  
Next.js app dir + Tailwind + shadcn/ui. Introduce design tokens (color, typography, spacing) and component primitives (Button, Card, StatBadge). Use TanStack Query for data, React Hook Form + Zod, Tremor or Recharts placeholder for charts. Reference high-trust fintech UI patterns.

**Deliverables**
- Pages: `/` (hero + trending markets), `/markets/[slug]`, `/create` wizard, `/dashboard` (positions + wallet).
- Components: `TradeModal`, `MarketChart` (placeholder w/ streaming updates), `SlippageBadge`, `LiquidityMeter`, `CreateMarketForm`, `EmptyState`, `TopBar`, `BottomNav` (mobile).
- Global style guide doc in `apps/web/README.design.md`.
- Skeleton/loading states, optimistic UI for trade submissions, error toasts, inline validations.

**Files**
- Page files under `apps/web/app/...`.
- Components under `apps/web/components/...`.
- Hooks `useTrade`, `useWallet`, `useLiveMarket`.
- Storybook stories + Playwright visual tests.

**Acceptance Criteria**
- Lighthouse ≥ 80 mobile / ≥ 90 desktop for `/markets/demo`.
- Trade modal shows price impact badge, leverage selector (disabled until Prompt 8), and risk copy.
- Create market wizard previews slippage via API before submission.
- Dashboard displays wallet balance + recent trades + open positions (placeholder data if none).

**Tests & Commands**
- `pnpm web:test` (Playwright) verifying trade modal + create flow.
- `pnpm storybook` runs; Chromatic or story snapshot tests.

**Implementation Notes**
- Mobile-first layout; ensure one-handed trade controls.
- Provide dark mode toggle.
- Include iconography plan (Lucide + custom strokes).

---

## Prompt 7 — Real-time infra (Redis pub/sub + WebSocket Gateway)

**Purpose**  
Stream trades, prices, and market status to clients reliably with auth-aware WebSocket gateway.

**Dependencies**  
Prompts 1-6 (backend APIs + UI hooking points).

**Context / Stack**  
`uWebSockets.js` or `ws` server co-located with API (behind same Fastify instance) using Redis pub/sub. Clients authenticate via JWT at connection handshake; support auto-reconnect with exponential backoff.

**Deliverables**
- WS server bridging Redis channels → client topics, with per-market subscriptions.
- Event schema versioning (`v1`). Types stored in shared package.
- Client hook `useMarketEvents` that handles connect/reconnect, presence heartbeat, backpressure handling.
- Integration test verifying swap triggers WS event consumed by frontend.

**Files**
- `services/api/src/ws/server.ts`.
- `services/api/src/events/index.ts`.
- `apps/web/hooks/useMarketEvents.ts`.
- Tests `services/api/tests/ws.spec.ts`.

**Acceptance Criteria**
- Authenticated client receives `trade.executed`, `market.updated`, `market.paused` events under 200 ms locally.
- Unauthorized clients rejected with 4401 code.
- Gateway exposes health endpoint and metrics (connected clients, dropped messages).

**Tests & Commands**
- Script `scripts/test-ws.ts` connecting, placing trade, verifying payload.

**Implementation Notes**
- Implement replay buffer (last 50 events per market) to catch up clients.
- Document protocol (subscribe/unsubscribe messages).

---

## Prompt 8 — Positions, margin calculator & soft liquidation worker

**Purpose**  
Track leveraged positions derived from AMM swaps, compute P&L, and enforce maintenance margin with automated soft liquidations.

**Dependencies**  
Prompts 1-7.

**Context / Stack**  
Positions service inside API (modularized). Default leverage cap 3x for MVP. Maintenance margin = `max(0.05, 0.02 * leverage)`. Liquidation penalty 2% routed to insurance fund ledger entry.

**Important**: For MVP, shorts use **perpetual-style contracts** (synthetic shorts, no borrowing needed). Long positions are direct AMM swaps. Both track margin and P&L the same way.

**Deliverables**
- API: `POST /positions/open` (wraps swap + position creation), `POST /positions/close`, `GET /positions`, `GET /positions/:id`.
- Margin calculator module with formulas + unit tests.
- Background worker (`services/api/src/workers/liquidations.ts`) run via `pnpm workers:liquidations`, recalculating P&L every N seconds using latest price (from AMM reserves).
- Soft liquidation flow: mark position, execute opposite swap, notify user via event log.

**Files**
- Service modules `positionService.ts`, `marginMath.ts`.
- Worker + scheduler config.
- Tests `positions.spec.ts`, `marginMath.spec.ts`, `liquidationWorker.spec.ts`.

**Acceptance Criteria**
- Opening 2x long at price 50.0 / $1,000 notional uses $500 margin, liquidation price computed deterministically (for long: liquidation_price = entry_price * (1 - 1/leverage + maintenance_margin)), tests assert values.
- Short positions work similarly but with inverted P&L calculation: profit when price decreases.
- Worker closes under-margined positions and records penalty entry.
- Event `position.liquidated` emitted with reason + metrics incremented.

**Tests & Commands**
- `pnpm test positions`.
- Simulated scenario script closing >1 position.

**Implementation Notes**
- Wrap swap + position open inside transaction to avoid divergence.
- Provide CLI command to backfill P&L (for cold start).
- Document how to tune leverage per market (config file).

---

## Prompt 9 — Deterministic simulator & chaos toolkit

**Purpose**  
Stress-test AMM + positions + liquidations with reproducible simulations before exposing to real users.

**Dependencies**  
Prompts 1-8.

**Context / Stack**  
Node-based simulator using TypeScript + `undici` for HTTP calls or direct service invocation. Accept CLI flags for number of markets, concurrency, trade size distribution, leverage mix, random seed.

**Deliverables**
- `tools/simulator/simulate.ts` generating trades, measuring slippage, P&L distribution, liquidation counts, insurance fund delta.
- Output JSON + CSV + summary markdown.
- Config file describing scenarios (bull, bear, volatile).
- CI smoke test running small simulation nightly.

**Files**
- `tools/simulator/simulate.ts`, `tools/simulator/config.example.json`.
- `tools/simulator/README.md`.
- CI job `ci-sim.yml` or extend base workflow.

**Acceptance Criteria**
- `pnpm simulate --markets=5 --trades=200 --seed=42` runs under 60 s locally, writing results to `tools/simulator/output/latest.json`.
- Stats include: mean slippage, worst slippage, # liquidations, insurance_balance_change.
- Failing thresholds (e.g., >30% mean slippage) cause nonzero exit code for CI.

**Tests & Commands**
- Unit tests for RNG + scenario builder.
- Golden snapshot of summary for known seed.

**Implementation Notes**
- Provide ability to run offline mode (mock HTTP) for speed.
- Hook metrics to `/metrics` endpoint for observability.

---

## Prompt 10 — Deployment, observability & ops checklist

**Purpose**  
Package the MVP for Railway deployment with basic observability, runbooks, and smoke tests so you can launch solo with confidence.

**Dependencies**  
Prompts 1-9.

**Context / Stack**  
Railway templates, GitHub Actions CD, OpenTelemetry metrics exported via `/metrics`, Sentry for errors, simple uptime probe script.

**Deliverables**
- Deployment docs: `README-deploy.md`, `railway.json`, environment matrix (dev/stage/prod) and secret naming.
- `/metrics` endpoint exposing counters/histograms: total_volume, active_markets, open_interest, insurance_balance, request_latency_ms.
- Sentry integration (dsn env). Health checks for API + WS.
- Runbook `ops/runbooks/phase1.md` covering: how to seed new market, restart workers, rotate secrets, rollback.
- Post-deploy smoke test script `scripts/post-deploy-check.ts`.

**Files**
- `.github/workflows/deploy.yml` (build → test → deploy with manual approval).
- `services/api/src/routes/metrics.ts`.
- `ops/runbooks/phase1.md`, `README-deploy.md`.

**Acceptance Criteria**
- GitHub Action on `main` runs tests, requires approval, deploys to Railway, runs smoke tests automatically.
- `/metrics` responds with JSON + correct content-type.
- Runbook includes checklists for outages + data corruption scenario.

**Tests & Commands**
- `pnpm test` (full suite) gates deploy.
- `pnpm ts-node scripts/post-deploy-check.ts https://<railway>` used by CI.

**Implementation Notes**
- Document log aggregation strategy (Railway logs + optional Logtail).
- Set up alerts (email/webhook) for metrics breaching thresholds (≥90% CPU, low liquidity).

---

## Prompt 11 — Multi-Stablecoin Deposit System & Alchemy Integration

**Purpose**  
Implement robust deposit detection system supporting all major stablecoins (USDC, USDT, DAI, PYUSD) on multiple networks (Ethereum, Polygon, Base, etc.) using Alchemy webhooks for automatic deposit detection and CoinGecko for USD conversion.

**Dependencies**  
Prompts 1-3 (schema + wallet + auth).

**Context / Stack**  
Alchemy SDK for blockchain monitoring, Alchemy webhooks for address activity, CoinGecko API for token prices, Fastify routes for webhook handling. Support unique deposit addresses per user/token/network.

**Deliverables**
- Alchemy webhook handler (`POST /webhooks/alchemy`) that:
  - Verifies webhook signature
  - Handles `ADDRESS_ACTIVITY` events
  - Matches transactions to user deposit addresses
  - Verifies token type (USDC, USDT, DAI, etc.)
  - Verifies network (Ethereum, Polygon, etc.)
  - Checks confirmations (12+ for Ethereum, 5+ for Polygon)
- Deposit processing service:
  - `services/api/src/services/depositService.ts`
  - Functions: `detectDeposit()`, `verifyDeposit()`, `creditUser()`
  - Get token price from CoinGecko (for USD conversion)
  - Credit user wallet (unified USD balance)
  - Create deposit record
  - Notify user (email + in-app)
- Deposit address generation:
  - `GET /wallet/deposit/address` - Get or generate unique deposit address
  - Support: USDC, USDT, DAI, PYUSD on multiple networks
  - Store in `UserDepositAddress` table
- CoinGecko integration:
  - `services/api/src/services/coinGeckoService.ts`
  - Functions: `getTokenPrice()`, `convertToUSD()`
  - Cache prices (5 minute TTL)
- Support all stablecoins:
  - USDC (Ethereum, Polygon, Base)
  - USDT (Ethereum, Polygon)
  - DAI (Ethereum, Polygon)
  - PYUSD (Ethereum, Base)

**Files**
- `services/api/src/routes/webhooks.ts` (Alchemy webhook handler)
- `services/api/src/services/depositService.ts`
- `services/api/src/services/coinGeckoService.ts`
- `services/api/src/services/depositAddressService.ts`
- Tests: `deposit.spec.ts`, `alchemyWebhook.spec.ts`

**Acceptance Criteria**
- Alchemy webhook receives address activity events and processes deposits correctly.
- Deposit detection matches transactions to correct user deposit addresses.
- Token prices fetched from CoinGecko and cached appropriately.
- Deposits credit user wallet with correct USD equivalent.
- Deposit records created with all transaction details.
- Users notified of successful deposits.

**Tests & Commands**
- `pnpm test deposit`
- Integration test: Send test transaction to deposit address, verify webhook processes it.
- Test with testnet transactions.

**Implementation Notes**
- Set up Alchemy webhooks for all networks (Ethereum, Polygon, Base).
- Configure webhook to monitor all user deposit addresses.
- Use idempotency keys to prevent duplicate processing.
- Handle webhook retries gracefully.
- Store transaction hash to prevent duplicate credits.
- Document Alchemy webhook setup in README.

---

## Prompt 12 — Instant Withdrawal System & Hot Wallet Management

**Purpose**  
Implement instant automated withdrawal system where users can withdraw any supported stablecoin to any address without platform permission. Includes hot wallet management for fast processing.

**Dependencies**  
Prompts 1-3, 11 (wallet + deposit system).

**Context / Stack**  
Alchemy SDK for sending transactions, hot wallet management, automated withdrawal worker, Fastify routes. Support withdrawals in all stablecoins on all networks.

**Deliverables**
- Withdrawal endpoint (`POST /wallet/withdraw`):
  - Accept: amount, token, network, withdrawal address
  - Validate: balance, limits, address format
  - Immediate debit from user balance (optimistic update)
  - Create withdrawal record (status: "pending")
  - Queue for processing
- Automated withdrawal worker:
  - `services/api/src/workers/withdrawalWorker.ts`
  - Processes pending withdrawals automatically
  - Runs every 30 seconds (or configurable)
  - Checks hot wallet balance
  - Replenishes from cold storage if needed
  - Sends transaction via Alchemy
  - Monitors confirmation
  - Updates withdrawal status
- Hot wallet management service:
  - `services/api/src/services/hotWalletService.ts`
  - Functions: `getHotWallet()`, `checkBalance()`, `replenishFromCold()`
  - Set up hot wallets for each token/network:
    - USDC on Ethereum
    - USDC on Polygon
    - USDT on Ethereum
    - USDT on Polygon
    - DAI on Ethereum
    - DAI on Polygon
  - Balance monitoring and alerts
- Withdrawal history endpoint:
  - `GET /wallet/withdraw/history`
  - Shows all withdrawals with status, transaction hash, etc.

**Files**
- `services/api/src/routes/wallet.ts` (withdrawal endpoint)
- `services/api/src/workers/withdrawalWorker.ts`
- `services/api/src/services/hotWalletService.ts`
- `services/api/src/services/withdrawalService.ts`
- Tests: `withdrawal.spec.ts`, `hotWallet.spec.ts`, `withdrawalWorker.spec.ts`

**Acceptance Criteria**
- Users can withdraw instantly without manual approval.
- Withdrawals process automatically within 30 seconds.
- Hot wallet balances monitored and replenished automatically.
- Transactions sent successfully via Alchemy.
- Withdrawal status updates correctly (pending → processing → completed).
- Users notified of withdrawal completion.

**Tests & Commands**
- `pnpm test withdrawal`
- Integration test: Create withdrawal, verify worker processes it, verify transaction sent.
- Test hot wallet replenishment flow.

**Implementation Notes**
- Keep hot wallet private keys in secure environment variables (use Railway secrets).
- Set up cold wallet for storing majority of funds (multi-sig recommended).
- Monitor hot wallet balances and alert when low.
- Handle withdrawal failures gracefully (refund user, retry logic).
- Document hot wallet setup and management in README.
- Set up alerts for low hot wallet balances.

---

## Cursor Usage Notes
- Every prompt should reference artifacts from prior prompts explicitly (Dependencies section).
- Provide copy-ready README snippets and inline comments; future self will rely on them.
- Favor deterministic tests; no "magic numbers" without explanation.
- For any manual step (e.g., seeding), include CLI commands/scripts so future automation is easy.
- **Remember**: Xmarket uses custodial wallets - no wallet connection needed. Users deposit directly to platform addresses.
